

Uninformed Search:


A search problem requires:

1. A state space
2. A world model of how states will change in response to actions (like a successor function)
3. Specification of a start state and a goal


World state: includes every detail of environment at time-step

Search state: state that keeps relevant details


Example 1: 8-tile puzzle


- states: locations of the 8 tiles and blank
- succ func: up, down, left right, or leave blank
- start state: given config
- goal state: desired config



- state space graph: mathematical representation of a search problem (nodes corresponding to individual states and edges corresponding to transitions between states)


-------------------------------------------------------------

DFS:


Time complexity: What nodes are expanded?
	• Some left prefix of the tree.
	• Could process the whole tree!
	• If m is finite, takes time O(bm) m tiers

Space Complexity: How much space does the fringe take?
	• Only has siblings on path to root, so O(bm)

Complete?
	• m could be infinite, so only if we prevent cycles

Optimal?
	• No, it finds the “leftmost” solution, regardless of depth or cost




DFS Limited: Same as DFS but depth limited to l, so time and space complexity is O(bl)




-------------------------------------------------------------

BFS:


Time Complexity: What nodes are expanded?
	• Processes all nodes above shallowest solution. Let depth of shallowest solution be s. Search takes time O(bs) s tiers

Space Complexity: How much space does the fringe take?
	• Has roughly the last tier, so O(bs)

Complete?
	• s must be finite if a solution exists, so yes!

Optimal?
	• Only if costs are all 1 (more on costs)


-----------------------------------------------------------

Uniform-Cost Search:


Time Complexity: If C* is the cost of the shallowest solution and each "arc" costs at least E, then O(b^(C*/E))

Space Complexity: O(b^(C*/E))

Complete: Assuming best solution has finite cost and minimum arc cost is positive, then yes

Optimal: Yes


----------------------------------------------------------


Beam Search:

- Maintain a constant sized frontier of size w, and in case frontier gets bigger than w, prune out all of the worst/expensive node paths until size gets back to w. 

- Complete: No

- Optimal: No



--------------------------------------------------------


Iterative Deepening:


- Depth Limited Search, but done iteratively on each depth
- complete: yes
- optimal: only if each step cost 1 (or in other words an unweighted graph)
- space complexity -> O(bd)
- time complexity -> O(bm)

---------------------------------------------------------

Bidirectional Traversal:

Do two simultaneous traversals on opposite ends of a graph, especially if a goal is at the middle

- select the path which is the cheapest 

- Time/Space Complexity -> O(b^(d/2))



